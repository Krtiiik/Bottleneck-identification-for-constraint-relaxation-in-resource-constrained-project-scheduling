\chapter{Numerical experiments}

% ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
\section{Setup}

\begin{itemize}
    \item PSPLIB instances
        Those are Seriesâ€“parallel graphs. (See the survey of \citep{PROT2017} for comparison of graph types
        used in scheduling.) We would, however, prefer precedence graphs which correspond better to our problem.



        \citet{KOLISCH1997} created a set of benchmark instances for resource-constrained project scheduling%
        \footnote{Available online at \url{https://www.om-db.wi.tum.de/psplib/}}.
        This set has since been used to \wording{evaluate many results in literature}. We select some of the instances
        to use in our experiments.

        The instances are, however, missing some properties required to \wording{properly simulate our experiments},
        namely: job deadlines, orders (with related tardiness weights) and variable capacities. We introduce
        those as extensions to the original instances.

        First, we split the single-component precedence graph (a series-parallel graph) into disconnected
        components, creating an inforest. We do this by ordering the jobs topologically, then selecting one
        of the last topological generations as the seed jobs%
            \footnote{The depth of the selected generation influences the number of created components and the
            overall structure of the created intree forest.}.
        Then incrementally, starting from the neighboring generations, for each job from each preceding generation
        a single successor precedence is selected for connecting the job to a single successor. Analogously,
        for each job from each succeeding generation a single predecessor precedence is selected.
        After splitting the graph into an inforest, the roots of the intrees are selected as orders $\Orders$.

        Second, we limit the resource availabilities to simulate working shifts. The capacity availability function
        of resources is a result of periodical availabilities from periodical intervals combined with single-time
        availabilities from exception intervals. We use periodical availability intervals, subintervals of $[1 .. 24]$,
        to denote that a resource is available (maximum capacity $\shiftcapacity{k}$) each day during the specified time
        intervals. Exception intervals, subinterals of $[1 .. \horizon]$, are used to denote a one-time resource
        availability change of a specified capacity. During time periods not covered by any intervals the capacity
        of the resource is zero.

        \todo{Due dates}

    \item Solving the CP model

    \item Modifying the instances based on the solutions proposed earlier

    \item Methods of evaluation
    
        Having the solution $\Schedule$ to the original problem instance $\Instance$
        and the solution $\Schedule^*$ to the modified problem instance $\Instance^*$,
        we compute the following:
        \begin{itemize}
            \item Tardiness improvement = $\tardiness{o} - \tardiness{o}^*$
            \item Solution difference = $\sum_{j \in J} \abs{\jobend{j} - \jobend{j}^*}$
            \item Upon specifying a capacity migration cost $\mathcal{C}_M$ and a capacity addition cost $\mathcal{C}_A$,
                the instance modification cost =
                \begin{align*}
                    \sum_{k \in \Resources} \sum_{t \in \intinterval{0}{\horizon}}
                    \big( &C_A \cdot [\capacity{k}{t} = 0] \cdot (\capacity{k}{t}^* - \capacity{k}{t} ) \\
                    &+ C_M \cdot [\capacity{k}{t} > 0 \land \capacity{k}{t}^* > \capacity{k}{t}] \big)
                \end{align*}

        \end{itemize}
\end{itemize}

% ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
\section{Comparative results}

% ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
\section{Discussion}
